import { ProviderRpcClient, Address } from 'everscale-inpage-provider'
import { toNano, fromNano } from '../../helpers/decimalParser'
import { addressConverter } from '../../helpers/addressParser'
import daoRootAbi from '../../helpers/DaoRoot.abi.json'
import daoFactoryAbi from '../../helpers/DaoFactory.abi.json'
import stakingRootDeployerAbi from '../../helpers/StakingRootDeployer.abi.json'
import proposalAbi from '../../helpers/Proposal.abi.json'
import stakingAbi from '../../helpers/Staking.abi.json'
import userDataAbi from '../../helpers/UserData.abi.json'
import tokenWalletAbi from '../../helpers/TokenWallet.abi.json'
import axios from 'axios'
import tokensList from 'utils/tokens-list'
import dayjs from 'dayjs'

const API_URL = 'https://tokens.everscan.io/v1/balances'
const ever = new ProviderRpcClient()

// STAKING ROOT ADDRESS TEST
const stakingDeployerAddressTest =
  '0:871e085a8e2f51d641af98013f5aa51bee0ac2257397980b7df6401ae3feacef'

const stakingDeployerAddressMain =
  '0:c1297cb6f620accdbd6d22a9d069e36f5e1fc5bc8b3d21f22a5dc368f7fa69f2'

const stakingDeployerAddressLocal =
  '0:e61e039e8bc3bc9c3a91544a5a762770f0ccce1e50ac16e09e154cae60567dd1'

const daoTvc =
  'te6ccgECIwEABb8AAgE0AwEBAcACAEPQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgBCSK7VMg4wMgwP/jAiDA/uMC8gsgBQQiA87tRNDXScMB+GaJ+Gkh2zzTAAGOIoMI1xgg+CjIzs7J+QAB0wABlNP/AwGTAvhC4iD4ZfkQ8qiV0wAB8nri0z8B+EMhufK0IPgjgQPoqIIIG3dAoLnytPhj0x8B+CO88rnTHwHbPPI8HBsGA1LtRNDXScMB+GYi0NMD+kAw+GmpOADcIccA4wIh1w0f8rwh4wMB2zzyPB8fBgM8IIIQLvqJVLvjAiCCEF/oRr674wIgghBiiBqouuMCEgkHA3gw+Eby4Ez4Qm7jACGT1NHQ3vpA0ds8IY4cI9DTAfpAMDHIz4cgzoIQ4ogaqM8LgfQAyXD7AJEw4ts88gAeCBoAfPgA+Er4TFyAIPQOlNMf9AWScG3ibwJVAgFvIiGkVSCAIPQWbwLIAW8iAssf9ABZgCD0Q/hs+EqktR/4avhMBFAgghAv81juuuMCIIIQNbEjELrjAiCCEDhEJGq64wIgghBf6Ea+uuMCEQ0LCgFQMNHbPPhMIY4cjQRwAAAAAAAAAAAAAAAAN/oRr6DIzvQAyXD7AN7yAB4DbDD4RvLgTPhCbuMA0x/R2zwhjhwj0NMB+kAwMcjPhyDOghC4RCRqzwuB9ADJcPsAkTDi2zzyAB4MGgAY+AD4TIAg9FswIPhsA8Yw+Eby4Ez4Qm7jACGW1NMf1NHQk9TTH+LTH9N/0x/Tf9MfVVBvBgHU1PpA1NHQ0//U0gDTH9TU0ds8IY4fI9DTAfpAMDHIz4cgznHPC2EByM+S1sSMQs7NyXD7AJEw4ts88gAeDhoC/vgAWF5w+ElVCStwyMv/cG2AQPRDVQvIyx9xWIBA9EPI9ADJVQvIz4SA9AD0AM+BySD5AMjPigBAy//J0FWwLMjPhYjOgoAh3NZQAAAAAAAAAAAAAAAAAAPPC44h2zzMz4NVoMjPkHQXB8LMAW8mXlDLH8sfy3/LH8t/yx/OzMwQDwDYVVDIzsv/zMoAzMzNzclw+wD4bfhK+ExcgCD0DpTTH/QFknBt4m8C+E0BbyIhpFUggCD0Fm8CyAFvIgLLH/QAWYAg9EP4bPhKpLUf+Gr4TY0EcAAAAAAAAAAAAAAAAA7+1zCgyM7OyXD7APhNADTQ0gABk9IEMd7SAAGT0gEx3vQE9AT0BNFfAwFQMNHbPPhKIY4cjQRwAAAAAAAAAAAAAAAAK/zWO6DIzssfyXD7AN7yAB4EUCCCEATGjvW64wIgghAciukbuuMCIIIQIcGEN7rjAiCCEC76iVS64wIdGRYTAzQw+Eby4Ez4Qm7jACGT1NHQ3vpA0ds82zzyAB4UGgFMiPhCwwD4QvhFIG6SMHDeurDy6+n4APgAyM+FiM6Ab89AyYMG+wAVADZPbmx5IHRoZSBvd25lciBjYW4gb3BlcmF0ZSEDaDD4RvLgTPhCbuMA0ds8IY4cI9DTAfpAMDHIz4cgzoIQocGEN88LgfQAyXD7AJEw4uMA8gAeGBcAKO1E0NP/0z8x+ENYyMv/yz/Oye1UAAT4TAJEMPhCbuMA+Ebyc9TR+EL4RSBukjBw3rry4+n4APsE2zzyABsaADr4TfhM+Ev4SvhD+ELIy//LP8+Dyx/LH/QAzsntVAJ07UTQ10nCAY6vcO1E0PQFcHEigED0Dm+Rk9cLH95tifht+Gz4a/hqgED0DvK91wv/+GJw+GNw+GrjDRweAEOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAVAw0ds8+EshjhyNBHAAAAAAAAAAAAAAAAAhMaO9YMjOyx/JcPsA3vIAHgA+7UTQ0//TP9MAMdMf0x/0BPpA0fht+Gz4a/hq+GP4YgAK+Eby4EwCEPSkIPS98sBOIiEAFHNvbCAwLjY2LjAAAA=='

const daoRootTvc =
  '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'

const proposalTvc =
  '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'

const platformTvc =
  'te6ccgECEgEAAjYAAgE0AwEBAcACAEPQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgBCSK7VMg4wMgwP/jAiDA/uMC8gsOBQQLA5btRNDXScMB+GaJ+Gkh2zzTAAGOFIMI1xgg+CjIzs7J+QBY+EL5EPKo3tM/AfhDIbnytCD4I4ED6KiCCBt3QKC58rT4Y9MfAds88jwMCQYDUu1E0NdJwwH4ZiLQ0wP6QDD4aak4ANwhxwDjAiHXDR/yvCHjAwHbPPI8DQ0GARQgghA/YUWcuuMCBwOCMPhCbuMA+EbycyGV1NTU0dCS1NTi+kDR+En4SscFjoRfMts8jhT4ScjPhQjOgG/PQMmDBqYgtQf7AOJfA9s88gAJCBEAbPhKyM74S88LB874TQHM+EwBzMwh+wQB0CCLOK2zWMcFk9dN0N7XTNDtHu1TyYIQfC8YCO1D2ASk7UTQ10nCAY/HcO1E0PQFcSGAQPQOjoGJ33IigED0Dm+Rk9cLB95zI4BA9A+OgYjfdCSAQPQPjoGI3/ht+Gz4a/hqgED0DvK91wv/+GJw+GPjDQwLCwoAOu1E0NP/0z/TADH6QNMH1NTR+G34bPhr+Gr4Y/hiAAAAQ4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAACvhG8uBMAhD0pCD0vfLAThAPABRzb2wgMC42Ni4wARigfC8YCDDbPPgP8gARADb4TfhM+Ev4SvhD+ELIy//LP8+DzssHzMzJ7VQ='

const userDataTvc =
  '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'

const electionTvc =
  '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'

const relayRoundTvc =
  'te6ccgECRQEAD+0AAgE0AwEBAcACAEPQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgBCSK7VMg4wMgwP/jAiDA/uMC8gs9BQRDA5btRNDXScMB+GaJ+Gkh2zzTAAGOFIMI1xgg+CjIzs7J+QBY+EL5EPKo3tM/AfhDIbnytCD4I4ED6KiCCBt3QKC58rT4Y9MfAds88jxEDAYDeu1E0NdJwwH4ZiLQ0wP6QDD4aak4APhEf29xggiYloBvcm1vc3BvdPhk3CHHAOMCIdcNH/K8IeMDAds88jw8PAYCKCCCEGSleMi74wIgghB8+T8Lu+MCDQcEUCCCEGi1Xz+64wIgghBqUvyUuuMCIIIQbvG16LrjAiCCEHz5Pwu64wILCgkIAVAw0ds8+EshjhyNBHAAAAAAAAAAAAAAAAA/Pk/C4MjOyx/JcPsA3vIAOwFQMNHbPPhQIY4cjQRwAAAAAAAAAAAAAAAAO7xteiDIzst/yXD7AN7yADsBUDDR2zz4TyGOHI0EcAAAAAAAAAAAAAAAADqUvyUgyM7LH8lw+wDe8gA7ARww+EJu4wD4RvJz0fLAZAwEoO1E0NdJwgGPxXDtRND0BXD4QPhB+EL4Q/hE+EX4RvhH+Ej4SXBfgIkgcCBtbwJfMG0gcF8giImAIW+A7VeAQPQO8r3XC//4YnD4Y3D4feMNRENEOwRQIIIQC5fKyrvjAiCCEB060Bi74wIgghA1cHOxu+MCIIIQZKV4yLvjAi0kGg4EUCCCEECFFTC64wIgghBKKOOpuuMCIIIQYTwsJ7rjAiCCEGSleMi64wIYFBMPA0Iw+Eby4Ez4Qm7jACGW1NMf1NHQk9TTH+L6QNHbPNs88gA7EEIBYIEJxvhJgCD4QMcF8vQh+F66jhiCEHc1lABw+wIgyM+FCM6Ab89AyYMG+wCOgOJfAxEB/iGNBHAAAAAAAAAAAAAAAAAe0Ml24MjOyx/JcPsAgCD4QMjOz4QCIc8W+F8BzPhVyMsfzSLIyx/4Xs8LH834SsjKAPhLzwsf+EzPCx/4Tc8LH/hOzwt/+E/PCx/4UM8Lf/hRAcoA+FLPCwf4V28iAssf9AD4WG8iAssf9ADIzxESAKb4U8jO+FTPFvhZbyICyx/0APhWbyICyx/0APhaAfQA+FsB9AD4XM8LB/hdzwv/zc0j+wQj0CCLOK2zWMcFk9dN0N7XTNDtHu1TyYIQfC8YCO1D2AFQMNHbPPhRIY4cjQRwAAAAAAAAAAAAAAAAOE8LCeDIzsoAyXD7AN7yADsDZDD4RvLgTPhCbuMA0x/0BFlvAgHTH/QEWW8CAdMf9ARZbwIB0x/0BFlvAgHR2zzbPPIAOxVCArCBCeT4SfhTxwX4SfhUxwX4SYAg+EDHBbGx8vSBCdT4SrPy9IIQdzWUAHD7AnCVUwRvELmOllMBbxGAIPQO8rLXC3/CAI6Aktsx4qTjGF8F+FyktQf4fNs8FisB/vhWUxVvEYAg9A7ystcL/8jL/wFvIiGkVSCAIPRDbwL4dvhXUxRvEYAg9A7ystcLn8jLnwFvIiGkVSCAIPRDbwL4d/hZUxJvEYAg9A7ystcLf8jLfwFvIiGkVSCAIPRDbwL4efhYUxNvEYAg9A7ysgFvIiGkVSCAIPQWbwIg+HgXAHBvEKW1//haUyRvEYAg9A7ysgLIy/9ZgQEL9EH4elMBbxGAIPQO8rLXC3/4TqC1f/hu+EuktR/4awPoMPhG8uBM+EJu4wDTH/hEWG91+GQhk9TR0N76QNHbPCGOGiPQ0wH6QDAxyM+HIM6CEMCFFTDPC4HKAMlwji/4RCBvEyFvEvhJVQJvEcjPhIDKAM+EQM4B+gL0AIBqz0D4RG8VzwsfygDJ+ERvFOL7AOMA8gA7GTcAdiD4WoEBC/QKb6ExjhD4RHBvcoBAb3Rwb3H4ZDBw4fhEcG9ygEBvdHBvcfhk+FuBAQv0Cm+Rk9cKAN6zBFAgghAizrI0uuMCIIIQJYXZI7rjAiCCECmfjFu64wIgghA1cHOxuuMCIyEgGwM4MPhG8uBM+EJu4wAhk9TR0N76QNMf0ds82zzyADscQgHkgQnG+EmAIPhAxwXy9I7ighB3NZQAcPsC+F34Vm8Qvo4UMMjPhYjOghAVLcD9zwuOyYMG+wDg+F3bPPh9XjDIz4WIzoIQSijjqc8LjgFvIgLLH/QAAW8iAssf9AABbyICyx/0AAFvIgLLH/QAyYMG+wDYHQLaIXDIy/9wbSOZXyKkA1iAIPRD5GwhbwIicMjLn3BtI5lfIqQDWIAg9EPkbCFvAiOJcG0jmV8ipANYgCD0FuRsIW8CJHDIy39wbSOZXyKkA1iAIPRD5GwhbwJVA3CaUwa5IvhWbxC5sI6A6DBsFUQeAfwh+FZvEYAg9A7ystcL/yZvIlIwUxK58rJVAsjL/1mAIPRDbwI2IfhXbxGAIPQO8rLXC58lbyJSMFMSufKyVQLIy59ZgCD0Q28CNSH4WG8RgCD0DvKyJG8iUjBTErnyshAjgCD0Fm8CNCH4WW8RgCD0DvKy1wt/I28iUjBTErkfACryslUCyMt/WYAg9ENvAjOktX8hpDIBUDDR2zz4TCGOHI0EcAAAAAAAAAAAAAAAACpn4xbgyM7LH8lw+wDe8gA7AyQw+Eby4Ez4Qm7jANHbPNs88gA7IkIAUoEJxvhJgCD4QMcF8vSBCd/4I/hNvvL0gCD4QMjPhQjOgG/PQMmDBvsAAVAw0ds8+E0hjhyNBHAAAAAAAAAAAAAAAAAos6yNIMjOyx/JcPsA3vIAOwRQIIIQD9H42LrjAiCCEBUtwP264wIgghAcHPqeuuMCIIIQHTrQGLrjAiwpJiUBUDDR2zz4TiGOHI0EcAAAAAAAAAAAAAAAACdOtAYgyM7Lf8lw+wDe8gA7A8Qw+Eby4Ez4Qm7jANMf+ERYb3X4ZNHbPCGOSCPQ0wH6QDAxyM+HIM5xzwthAcjPknBz6noBbyhecM7LHwFvIgLLH/QAAW8iAssf9AABbyICyx/0AAFvIgLLH/QAygDLH83JcDsoJwHKjlz4RCBvEyFvEvhJVQJvEcjPhIDKAM+EQM4B+gL0AHHPC2kByPhEbxXPCx8BbyhecM7LHwFvIgLLH/QAAW8iAssf9AABbyICyx/0AAFvIgLLH/QAygDLH83J+ERvFOL7AOMA8gA3AET4RHBvcnBvcYBAb3T4ZIAg+ED4VfhW+Ff4WPhZ+Er4Xm8IAyQw+Eby4Ez4Qm7jANHbPNs88gA7KkIBWIEJ5PhJ+FPHBfhJ+FTHBbHy9IEJ1PhKs/L0ghB3NZQAcPsC+FyktQf4fNs8KwC++Fz4UrqORX/4avhX+FH4T/hQ+Ev4TfhM+FWAIPhAyM+FiM5xzwtuVXDIz5DhhRcayx/LH8sfyx/Lf8sfygABbyICyx/0AM3Jgwb7AOCAIPhAyM+FCM6Ab89AyYMG+wABUDDR2zz4UiGOHI0EcAAAAAAAAAAAAAAAACP0fjYgyM7LB8lw+wDe8gA7BFAgghAEJwKJuuMCIIIQBgKiE7rjAiCCEAsArSa64wIgghALl8rKuuMCNjMwLgPwMPhG8uBM+EJu4wDTH/hEWG91+GTR2zwhjiAj0NMB+kAwMcjPhyDOghCLl8rKzwuBAW8iAssf9ADJcI41+EQgbxMhbxL4SVUCbxHIz4SAygDPhEDOAfoC9ACAas9A+ERvFc8LHwFvIgLLH/QAyfhEbxTi+wDjAPIAOy83ACD4RHBvcnBvcYBAb3T4ZPhWAzgw+Eby4Ez4Qm7jACGT1NHQ3vpA0x/R2zzbPPIAOzFCAvAh2zyBCcgB+EnHBfL0gQnf+CP4Tb7y9IEJ4CL4W4EBC/QKb5GT1woA3nC68vSBCeYB+F668vSBCeoh+FqBAQv0Cm+hMfL0ghB3NZQAcPsCIPhbyM+DWYEBC/RB+Hv4WoEBC/QKb5GT1wv/3vhZbxGAIPQO8rLXC384MgB+gjAN4Lazp2QAAKj4TqkE+FCogjAN4Lazp2QAAKkEtX/4T/hV+EnIz4WIzoIQdARuj88Ljssfyx/Lf8mDBvsAA5Iw+Eby4Ez4Qm7jANMf+ERYb3X4ZCGT1NHQ3vpA0ds8JI4nJtDTAfpAMDHIz4cgznHPC2FeMMjPkhgKiE7L/8ufWcjOy3/NzclwOzU0AYiOO/hEIG8TIW8S+ElVAm8RyM+EgMoAz4RAzgH6AvQAcc8LaV4wyPhEbxXPCx/L/8ufWcjOy3/Nzcn4RG8U4vsA4wDyADcAxIEJ6iH4WoEBC/QKb6Ex8vT4WoEBC/QKb5GT1wv/3vhEcG9ygEBvdHBvcfhkIPhWbxGAIPQO8rLXC/8h+FdvEYAg9A7ystcLnyL4WG8RgCD0DvKyVQL4WW8RgCD0DvKy1wt/A/Iw+Eby4Ez4Qm7jANMf+ERYb3X4ZCGT1NHQ3vpA0ds8IY4dI9DTAfpAMDHIz4cgznHPC2EByM+SEJwKJs7NyXCOMfhEIG8TIW8S+ElVAm8RyM+EgMoAz4RAzgH6AvQAcc8LaQHI+ERvFc8LH87NyfhEbxTi+wDjAPIAOzg3ACjtRNDT/9M/MfhDWMjL/8s/zsntVAJA+ERwb3Jwb3GAQG90+GSAZAHbPNs8+QDIz4oAQMv/ydA6OQB6cMjL/3BtgED0Q4Ag+EBxWIBA9BZYyMsHcliAQPRDcwGAQPQX+F90WIBA9BfI9ADJ+F/Iz4SA9AD0AM+ByQAGyM7JAPjtRNDT/9M/0wAx0gDTH9Mf0x/Tf9Mf03/SANMH1NHQ+kDU0dD6QNMf0x/0BFlvAgHTH/QEWW8CAdMf9ARZbwIB1NHQ0x/0BFlvAgH0BPQE0wfT/9Mf1PpA0XD4QPhB+EL4Q/hE+EX4RvhH+Ej4SYAXemOAIW+A7Vf4Y/hiAAr4RvLgTAIQ9KQg9L3ywE4/PgAUc29sIDAuNjYuMASmoHwvGAhw+Gpw+Gtw+Gxw+G1w+G5w+G9w+HBw+HFw+HKJ+HOJ+HRw+HVwbW8C+HZwbW8C+HdwbW8C+HhwbW8C+Hlt+Hpt+Htw+Hxw+H1w+H6I+H9ERENAAvyJgCD4YIIQdzWUAHD7AtAg+kDTB/pANFuAIPhgINQy+H/V1wsf+HXVMSDTH9MfMzD4fiDTHzL4bCDTHzL4bSDTHzL4byDTfzL4cCDSADL4cSDTBzL4ciD6QDL4c/pAMPh0+FH4VYAg+EDIz4WIzoIQefWqjM8LjssfygDJgwZEQQEQ+wDbPPgP8gBCANztR3CAIW+HgCJvgjCAIXBkXwr4Q/hCyMv/yz/Pg8oAyx/LH8sfy3/LH8t/ygDLB1XQyM5VwMjOyx8BbyICyx/0AAFvIgLLH/QAAW8iAssf9ABVcMgBbyICyx/0APQA9ADLB8v/yx/Mzs3NzcntVAAAAEOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ'
const deployOptions = {
  initParams: { _nonce: (Math.random() * 64000) | 0 },
  tvc: daoTvc,
}

const rootAbi = {
  'ABI version': 2,
  version: '2.2',
  header: ['pubkey', 'time', 'expire'],
  functions: [
    {
      name: 'walletOf',
      inputs: [
        { name: 'answerId', type: 'uint32' },
        { name: 'walletOwner', type: 'address' },
      ],
      outputs: [{ name: 'value0', type: 'address' }],
    },
    {
      name: 'symbol',
      inputs: [{ name: 'answerId', type: 'uint32' }],
      outputs: [{ name: 'value0', type: 'string' }],
    },
    {
      name: 'decimals',
      inputs: [{ name: 'answerId', type: 'uint32' }],
      outputs: [{ name: 'value0', type: 'uint8' }],
    },
    {
      name: 'name',
      inputs: [{ name: 'answerId', type: 'uint32' }],
      outputs: [{ name: 'value0', type: 'string' }],
    },
  ],
  data: [],
  events: [],
}

const giver = {
  'ABI version': 2,
  version: '2.2',
  header: ['time', 'expire'],
  functions: [
    {
      name: 'sendTransaction',
      inputs: [
        { name: 'dest', type: 'address' },
        { name: 'value', type: 'uint128' },
        { name: 'bounce', type: 'bool' },
      ],
      outputs: [],
    },
    {
      name: 'transfer',
      inputs: [
        { name: 'amount', type: 'uint128' },
        { name: 'recipient', type: 'address' },
        { name: 'deployWalletValue', type: 'uint128' },
        { name: 'remainingGasTo', type: 'address' },
        { name: 'notify', type: 'bool' },
        { name: 'payload', type: 'cell' },
      ],
      outputs: [],
    },
    {
      name: 'getMessages',
      inputs: [],
      outputs: [
        {
          components: [
            { name: 'hash', type: 'uint256' },
            { name: 'expireAt', type: 'uint64' },
          ],
          name: 'messages',
          type: 'tuple[]',
        },
      ],
    },
    {
      name: 'upgrade',
      inputs: [{ name: 'newcode', type: 'cell' }],
      outputs: [],
    },
    {
      name: 'constructor',
      inputs: [],
      outputs: [],
    },
    {
      name: 'balance',
      inputs: [{ name: 'answerId', type: 'uint32' }],
      outputs: [{ name: 'value0', type: 'uint128' }],
    },
  ],
  data: [],
  events: [],
  fields: [
    { name: '_pubkey', type: 'uint256' },
    { name: '_constructorFlag', type: 'bool' },
    { name: 'm_messages', type: 'map(uint256,uint64)' },
  ],
}

let tokenRootAddr
const getExpectedAddress = async () => {
  try {
    const address = await ever.getExpectedAddress(daoFactoryAbi, deployOptions)

    return Promise.resolve(address._address)
  } catch (e) {
    return Promise.reject(e)
  }
}

const getAddressForRoot = async () => {
  const deployParams = {
    initParams: { _nonce: (Math.random() * 64000) | 0 },
    tvc: daoRootTvc,
  }
  let rootAddressObject
  const address = await ever.getExpectedAddress(daoRootAbi, deployParams)
  if (!address) {
  } else {
    rootAddressObject = {
      rootAddress: address._address,
      nonce: deployParams.initParams._nonce,
    }
    localStorage.setItem('daoRootAddress', JSON.stringify(rootAddressObject))
  }
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(rootAddressObject)
    })
  })
}

const topup = async (addressDao, ownerAddress) => {
  const giverContract = new ever.Contract(giver, addressDao)

  const sendTransaction = await giverContract.methods
    .sendTransaction({
      value: toNano(1, 9),
      dest: addressDao,
      bounce: false,
    })
    .send({
      from: ownerAddress,
      amount: toNano(1, 9),
      bounce: false,
    })
  localStorage.setItem('topupV', JSON.stringify(1))
  return sendTransaction
}

const deployFactory = async (
  pendingPeriod,
  voting,
  quorum,
  queued,
  threshold,
  execution,
  name,
  slug,
  governanceToken,
  minStake,
  description,
  treasury,
  nonce,
  ownerAddress
) => {
  const accounts = await getFactory(ownerAddress)
  const treasure = treasury === 'on' ? true : treasury
  try {
    if (accounts.accounts && accounts.accounts.length > 0) {
      const address = accounts.accounts[0]._address
      const daoDeployer = await deployDAOFromFactory(
        pendingPeriod,
        voting,
        quorum,
        queued,
        threshold,
        execution,
        name,
        slug,
        governanceToken,
        minStake,
        description,
        treasure,
        address,
        nonce,
        ownerAddress
      )
      return Promise.resolve(accounts)
    } else {
      const address = await getExpectedAddress()
      if (address) {
      }

      const topupVar = await topup(address, ownerAddress)
      if (topupVar) {
      }

      const code = await ever.splitTvc(daoTvc)
      const hash2 = await ever.setCodeSalt({
        code: code.code,
        salt: {
          structure: [{ name: 'ownerAddress', type: 'address' }],
          data: { ownerAddress: ownerAddress },
        },
      })
      const stateInit = await ever.getStateInit(daoFactoryAbi, deployOptions)
      const daoFactoryContract = new ever.Contract(
        daoFactoryAbi,
        new Address(address)
      )
      const providerState = await ever.getProviderState()
      const publicKey = providerState.permissions.accountInteraction.publicKey
      const sendTransaction = await daoFactoryContract.methods
        .constructor({ newCode: hash2.code })
        .sendExternal({
          stateInit: stateInit.stateInit,
          publicKey: publicKey,
          withoutSignature: true,
        })
      const parsedSlug = slug.split('/')
      const daoDeployer = await deployDAOFromFactory(
        pendingPeriod,
        voting,
        quorum,
        queued,
        threshold,
        execution,
        name,
        slug,
        governanceToken,
        minStake,
        description,
        treasure,
        address,
        nonce,
        ownerAddress
      )

      return Promise.resolve(sendTransaction)
    }
  } catch (e) {
    return Promise.reject(e)
  }
}

const deployDAOFromFactory = async (
  pendingPeriod,
  voting,
  quorum,
  queued,
  threshold,
  execution,
  name,
  slug,
  governanceToken,
  minStake,
  description,
  treasury,
  factoryAddress,
  nonce,
  ownerAddress
) => {
  const daoAddr = factoryAddress
  const daoFactoryContract = new ever.Contract(
    daoFactoryAbi,
    new Address(daoAddr)
  )
  tokenRootAddr = governanceToken
  const code = await ever.splitTvc(daoRootTvc)
  const platformCode = await ever.splitTvc(platformTvc)
  const proposalCode = await ever.splitTvc(proposalTvc)
  const nr = (await daoFactoryContract.methods.getDeployedDAOs({}).call())
    .daoAddr.length
  try {
    const deployDao = await daoFactoryContract.methods
      .deploy({
        platformCode_: code.code,
        proposalConfiguration_: {
          votingDelay: pendingPeriod,
          votingPeriod: voting,
          quorumVotes: quorum,
          timeLock: queued,
          threshold: threshold,
          gracePeriod: execution,
        },
        name_: name,
        slug_: slug,
        governanceToken_: governanceToken,
        minStake_: toNano(minStake, 9),
        description_: description,
        treasury_: treasury,
        nonce_: nonce,
        code_: platformCode.code,
        proposalCode_: proposalCode.code,
      })
      .send({
        from: ownerAddress,
        amount: toNano(1, 9),
        bounce: true,
      })
    const delay = (ms) => new Promise((res) => setTimeout(res, ms))
    await delay(10000)
    const pastEvents = await daoFactoryContract.getPastEvents({
      range: { fromLt: 135 },
    })
    const p = await daoFactoryContract.decodeTransaction({
      transaction: deployDao,
      methods: [daoFactoryAbi['deploy']],
    })

    const daos = await daoFactoryContract.methods.getDeployedDAOs({}).call()
    let deployStaking
    let setActive
    if (daos.daoAddr.length > nr) {
      let stakingDeployerAddress
      const state = await ever.getProviderState()
      if (state.selectedConnection === 'localnet') {
        stakingDeployerAddress = stakingDeployerAddressLocal
      } else if (state.selectedConnection === 'testnet') {
        stakingDeployerAddress = stakingDeployerAddressTest
      } else {
        stakingDeployerAddress = stakingDeployerAddressMain
      }

      // console.log('stakingDeployerAddress: ', stakingDeployerAddress)

      deployStaking = await deployStakingContract(
        ownerAddress,
        daos.daoAddr[daos.daoAddr.length - 1][1][0]._address,
        stakingDeployerAddress
      )
      // console.log('deployStaking: ', deployStaking)

      const daoRootContract = new ever.Contract(
        daoRootAbi,
        daos.daoAddr[daos.daoAddr.length - 1][1][0]._address
      )
      const providerState = await ever.getProviderState()
      const publicKey = providerState.permissions.accountInteraction.publicKey

      const setStaking = await daoRootContract.methods
        .setStakingRoot({ newStakingRoot: deployStaking._address })
        .sendExternal({ publicKey: publicKey, withoutSignature: true })

      setActive = await setStakingActive(deployStaking._address, ownerAddress)
    }
    return Promise.resolve(setActive)
  } catch (e) {
    return Promise.reject(e)
  }
}

const deployStakingContract = async (
  ownerAddress,
  daoRoot,
  stakingDeployerAddress
) => {
  const stakingDeployer = new ever.Contract(
    stakingRootDeployerAbi,
    stakingDeployerAddress
  )
  try {
    const platformCode = await ever.splitTvc(platformTvc)
    const userDataCode = await ever.splitTvc(userDataTvc)
    const electionCode = await ever.splitTvc(electionTvc)
    const relayRoundCode = await ever.splitTvc(relayRoundTvc)

    const stakingContract = await stakingDeployer.methods
      .deploy({
        _admin: ownerAddress,
        _tokenRoot: tokenRootAddr,
        _dao_root: daoRoot,
        _rewarder: ownerAddress,
        _rescuer: ownerAddress,
        _bridge_event_config_eth_ton:
          '0:102cf118b6875d201a3011d5dc17a358ee4d4333ad7e167824515171ed8f6f63',
        _bridge_event_config_ton_eth:
          '0:102cf118b6875d201a3011d5dc17a358ee4d4333ad7e167824515171ed8f6f63',
        _deploy_nonce: (Math.random() * 64000) | 0,
        _platformCode: platformCode.code,
        _userDataCode: userDataCode.code,
        _electionCode: electionCode.code,
        _relayRoundCode: relayRoundCode.code,
      })
      .send({
        from: ownerAddress,
        amount: toNano(3, 9),
        bounce: false,
      })
    const delay = (ms) => new Promise((res) => setTimeout(res, ms))
    await delay(10000)
    let trx = await ever.getTransactions({
      address: stakingDeployer._address,
      continuation: undefined,
      limit: 1,
    })

    // console.log('trx: ', trx)
    while (trx.transactions[0].outMessages.length < 1) {
      trx = await ever.getTransactions({
        address: stakingDeployer._address,
        continuation: undefined,
        limit: 1,
      })

      if (trx.transactions[0].outMessages.length > 0) break
    }
    const p = await stakingDeployer.decodeTransaction({
      transaction: trx.transactions[0],
      methods: [stakingRootDeployerAbi['deploy']],
    })
    // console.log('p: ', p)

    // console.log(
    //   'stakingContract: ',
    //   trx.transactions[0].outMessages[0].dst._address
    // )

    const staking = new ever.Contract(
      stakingAbi,
      trx.transactions[0].outMessages[0].dst._address
    )

    const contractState = await ever.getFullContractState({
      address: trx.transactions[0].outMessages[0].dst._address,
    })
    // console.log('contract state: ', contractState)
    return Promise.resolve(staking)
  } catch (e) {
    // console.log(e)
    return Promise.reject(e)
  }
}

const setStakingActive = async (stakingContractAddress, ownerAddress) => {
  const stakingRoot = new ever.Contract(stakingAbi, stakingContractAddress)
  const providerState = await ever.getProviderState()
  const publicKey = providerState.permissions.accountInteraction.publicKey
  try {
    const setUserData = await stakingRoot.methods
      .setActive({
        new_active: true,
        send_gas_to: ownerAddress,
      })
      .sendExternal({
        publicKey: publicKey,
        withoutSignature: true,
      })
    // console.log(setUserData)
    const event = await stakingRoot.getPastEvents({
      range: { fromLt: setUserData.transaction.id.lt * 1 - 1 },
    })
    // console.log('event: ', event)
    return Promise.resolve(setUserData)
  } catch (e) {
    // console.log(e)
    return Promise.reject(e)
  }
}

const getFactory = async (address) => {
  const code = await ever.splitTvc(daoTvc)
  const hashEver = await ever.setCodeSalt({
    code: code.code,
    salt: {
      structure: [{ name: 'ownerAddress', type: 'address' }],
      data: { ownerAddress: address },
    },
  })
  const bocHashEver = await ever.getBocHash(hashEver.code)
  const accounts = await ever.getAccountsByCodeHash({
    codeHash: bocHashEver,
    limit: 10,
  })
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(accounts)
    })
  })
}

const addDaoRootToFactory = async (
  daoFactoryContract,
  newDaoAddress,
  publicKey
) => {
  try {
    const novi = await daoFactoryContract.methods
      .addNewDao({
        newDao: newDaoAddress,
      })
      .sendExternal({
        publicKey: publicKey,
        withoutSignature: true,
      })
    return Promise.resolve(novi)
  } catch (e) {
    // console.log('error: ', e)
    return Promise.reject(e)
  }
}

const getAllDAOs = async (address) => {
  const factory = await getFactory(address)
  const state = await ever.getProviderState()
  // console.log('provider: ', state)
  let rootData = []
  try {
    if (factory.accounts && factory.accounts.length > 0) {
      const daoFactoryContract = new ever.Contract(
        daoFactoryAbi,
        factory.accounts[0]._address
      )

      let daoAddresses = await getDeployedDaos(daoFactoryContract)

      for (let i = 0; i < daoAddresses.daoAddr.length; i++) {
        const daoRootContract = new ever.Contract(
          daoRootAbi,
          daoAddresses.daoAddr[i][1][0]._address
        )

        const name = await daoRootContract.methods.name({}).call()
        const description = await daoRootContract.methods.description({}).call()
        const slug = await daoRootContract.methods.slug({}).call()
        rootData.push({
          name: name.name,
          description: description.description,
          slug: 'daobuilder.nswebdevelopment.com/dao/' + slug.slug,
          address: daoAddresses.daoAddr[i][1][0]._address,
        })
      }

      const code = await ever.splitTvc(daoRootTvc)
      const walletAddress = addressConverter(localStorage.getItem('wallet'))

      const bocHashEver = await ever.getBocHash(code.code)
      const accounts = await ever.getAccountsByCodeHash({
        codeHash: bocHashEver,
        limit: 50,
      })
      daoAddresses = await getDeployedDaos(daoFactoryContract)
      if (rootData.length < daoAddresses.daoAddr.length) {
        const idx = daoAddresses.daoAddr.length - 1
        const daoRootContract = new ever.Contract(
          daoRootAbi,
          daoAddresses.daoAddr[idx][1][0]._address
        )
        const name = await daoRootContract.methods.name({}).call()
        const description = await daoRootContract.methods.description({}).call()
        const slug = await daoRootContract.methods.slug({}).call()
        rootData.push({
          name: name.name,
          description: description.description,
          slug: 'daobuilder.nswebdevelopment.com/dao/' + slug.slug,
          address: daoAddresses.daoAddr[idx][1][0]._address,
        })
      }
      if (accounts.accounts.length > 0) {
        for (let i = 0; i < accounts.accounts.length; i++) {
          let flag = 0
          for (let j = 0; j < daoAddresses.daoAddr.length; j++) {
            if (
              accounts.accounts[i]._address ===
              daoAddresses.daoAddr[j][1][0]._address
            ) {
              flag = 1
            }
          }
          if (flag === 0) {
            const daoRootContract = new ever.Contract(
              daoRootAbi,
              accounts.accounts[i]._address
            )
            const admin = await daoRootContract.methods
              .getAdmin({ answerId: 0 })
              .call()
            let counter = 0
            if (admin.value0._address === walletAddress) {
              const name = await daoRootContract.methods.name({}).call()
              const description = await daoRootContract.methods
                .description({})
                .call()
              const slug = await daoRootContract.methods.slug({}).call()
              const providerState = await ever.getProviderState()
              const publicKey =
                providerState.permissions.accountInteraction.publicKey
              counter = counter + 1
              if (counter == 1) {
                const novi = await addDaoRootToFactory(
                  daoFactoryContract,
                  accounts.accounts[i]._address,
                  publicKey
                )
              }
              daoAddresses = await getDeployedDaos(daoFactoryContract)
              rootData.push({
                name: name.name,
                description: description.description,
                slug: 'daobuilder.nswebdevelopment.com/dao/' + slug.slug,
                address: accounts.accounts[i]._address,
              })
            }
          }
        }
      }
      // console.log('root data: ', rootData)
      return Promise.resolve(rootData)
    } else {
      const code = await ever.splitTvc(daoRootTvc)
      const walletAddress = addressConverter(localStorage.getItem('wallet'))

      const bocHashEver = await ever.getBocHash(code.code)
      const accounts = await ever.getAccountsByCodeHash({
        codeHash: bocHashEver,
        limit: 50,
      })
      if (accounts.accounts.length > 0) {
        for (let i = 0; i < accounts.accounts.length; i++) {
          const daoRootContract = new ever.Contract(
            daoRootAbi,
            accounts.accounts[i]._address
          )
          const admin = await daoRootContract.methods
            .getAdmin({ answerId: 0 })
            .call()
          if (admin.value0._address === walletAddress) {
            const name = await daoRootContract.methods.name({}).call()
            const description = await daoRootContract.methods
              .description({})
              .call()
            const slug = await daoRootContract.methods.slug({}).call()
            rootData.push({
              name: name.name,
              description: description.description,
              slug: 'daobuilder.nswebdevelopment.com/dao/' + slug.slug,
              address: accounts.accounts[i]._address,
            })
          }
        }
        return Promise.resolve(rootData)
      }
    }
  } catch (e) {
    return Promise.reject(e)
  }
}

const getDeployedDaos = async (daoFactoryContract) => {
  try {
    const daoAddresses = await daoFactoryContract.methods
      .getDeployedDAOs({})
      .call()

    return Promise.resolve(daoAddresses)
  } catch (e) {
    // console.log('error: ', e)
    return Promise.reject(e)
  }
}

const transferOwnership = async (newOwnerAddress, id, address) => {
  const factory = await getFactory(address)
  const daoFactoryContract = new ever.Contract(
    daoFactoryAbi,
    factory.accounts[0]._address
  )
  const daoRootContract =
    id.length > 60
      ? await getDaoByAddress(id)
      : await findDaoBySlug(daoFactoryContract, id)
  const daoAddresses = await getDeployedDaos(daoFactoryContract)

  const nonce = daoAddresses.daoAddr.find(
    (address) => address[1][0]._address == daoRootContract.address
  )

  try {
    const walletAddress = addressConverter(localStorage.getItem('wallet'))

    const trx = await daoRootContract.methods
      .transferAdmin({ newAdmin: newOwnerAddress })
      .send({ from: walletAddress, amount: toNano(1, 9), bounce: false })
    const providerState = await ever.getProviderState()
    const publicKey = providerState.permissions.accountInteraction.publicKey
    const deleteOld = await daoFactoryContract.methods
      .removeDao({ nonce: nonce[0] * 1 })
      .sendExternal({
        publicKey: publicKey,
        withoutSignature: true,
      })
    return Promise.resolve(deleteOld)
  } catch (e) {
    // console.log('error: ', e)
    return Promise.reject(e)
  }
}

const destroy = async (id, address) => {
  const factory = await getFactory(address)
  const daoFactoryContract = new ever.Contract(
    daoFactoryAbi,
    factory.accounts[0]._address
  )
  const daoRootContract =
    id.length > 60
      ? await getDaoByAddress(id)
      : await findDaoBySlug(daoFactoryContract, id)
  const daoAddresses = await getDeployedDaos(daoFactoryContract)

  const nonce = daoAddresses.daoAddr.find(
    (address) => address[1][0]._address == daoRootContract.address
  )

  const walletAddress = addressConverter(localStorage.getItem('wallet'))
  try {
    const trx = await daoRootContract.methods
      .destroy({})
      .send({ from: walletAddress, amount: toNano(1, 9), bounce: false })
    const providerState = await ever.getProviderState()
    const publicKey = providerState.permissions.accountInteraction.publicKey

    const deleteOld = await daoFactoryContract.methods
      .removeDao({ nonce: nonce[0] * 1 })
      .sendExternal({
        publicKey: publicKey,
        withoutSignature: true,
      })
    return Promise.resolve(deleteOld)
  } catch (e) {
    // console.log('error: ', e)
    return Promise.reject(e)
  }
}
let tokenAddr
const getBalances = async (address) => {
  const walletAddress = address
  let data = JSON.stringify({
    ownerAddress: walletAddress,
    limit: 100,
    offset: 0,
    ordering: 'amountdescending',
  })

  const config = {
    method: 'post',
    url: 'https://tokens.everscan.io/v1/balances',
    headers: {
      'Content-Type': 'application/json',
    },
    data: data,
  }

  return axios(config)
    .then(function (response) {
      tokenAddr = response.data
    })
    .catch(function (error) {
      // console.log(error)
    })
}

const getToken = async (address) => {
  const root = new ever.Contract(rootAbi, address)
  try {
    const label = await root.methods.symbol({ answerId: 1 }).call()
    const decimals = await root.methods.decimals({ answerId: 0 }).call()
    const name = await root.methods.name({ answerId: 0 }).call()
    const token = tokensList.find((token) => token.label === label.value0)
    const tokenData = {
      label: label,
      icon: token ? token.icon : '',
      decimals: decimals.value0,
      name: name.value0,
    }
    return Promise.resolve(tokenData)
  } catch (e) {
    // console.log(e)
    return null
  }
}

const getTokenBalance = async (accAddr, govToken) => {
  const rootAcc = new ever.Contract(rootAbi, govToken)
  let response
  await getBalances(accAddr)
  try {
    response = await rootAcc.methods
      .walletOf({
        answerId: 1,
        walletOwner: accAddr,
      })
      .call()
    const balance = tokenAddr.balances.find(
      (token) => token.rootAddress === govToken
    )
    response = balance.amount * 1
    return Promise.resolve(response)
  } catch (e) {
    // console.log('e: ', e)
    return null
  }
}

const findDaoBySlug = async (factory, slug) => {
  let daoRoot
  let daoAddresses = await getDeployedDaos(factory)
  try {
    for (let i = 0; i < daoAddresses.daoAddr.length; i++) {
      const daoRootContract = new ever.Contract(
        daoRootAbi,
        daoAddresses.daoAddr[i][1][0]._address
      )

      const slugCheck = await daoRootContract.methods.slug({}).call()
      if (slugCheck.slug == slug) daoRoot = daoRootContract
    }
    return Promise.resolve(daoRoot)
  } catch (e) {
    // console.log('error: ', e)
    return null
  }
}

const getDaoInfo = async (id, address) => {
  const factory = await getFactory(address)
  let rootData = {}
  if (factory.accounts && factory.accounts.length > 0) {
    const daoFactoryContract = new ever.Contract(
      daoFactoryAbi,
      factory.accounts[0]._address
    )
    const daoRootContract =
      id.length > 60
        ? await getDaoByAddress(id)
        : await findDaoBySlug(daoFactoryContract, id)

    console.log('daoRootContract: ', daoRootContract)
    const name = await daoRootContract.methods.name({}).call()
    const slug = await daoRootContract.methods.slug({}).call()
    const description = await daoRootContract.methods.description({}).call()
    const tokenAddress = await daoRootContract.methods
      .governanceToken({})
      .call()

    const stakingRootContract = await createStakingContract(
      daoRootContract.address
    )

    const details = await stakingRootContract.methods
      .getDetails({ answerId: 0 })
      .call()
    const balance = fromNano(details.value0.tokenBalance * 1, 9)
    const tokenRootAddress = details.value0.tokenRoot
    const userData = await createUserDataContract(
      daoRootContract.address,
      address
    )
    const contractState = await ever.getFullContractState({
      address: userData.address,
    })
    let userBalance
    if (contractState?.state?.isDeployed) {
      const details = await userData.methods.getDetails({ answerId: 0 }).call()
      userBalance = fromNano(details.value0.token_balance * 1, 9)
    }
    const tokenSymbol = await getToken(tokenAddress.governanceToken._address)

    const proposalConfiguration = await daoRootContract.methods
      .proposalConfiguration({})
      .call()
    const nrOfProposals = await daoRootContract.methods.proposalCount({}).call()
    const proposals = await getProposals(daoRootContract.address)
    // console.log('proposals data: ', proposals)

    const prop = await proposalsWithYourLockedTokens(
      address,
      daoRootContract.address
    )

    const voters = await getAllStakeholders(daoRootContract.address)
    const tokenBalance = await calculateBalance(
      address,
      tokenAddress.governanceToken._address
    )
    const history = await getTransactionHistory(daoRootContract.address)
    const canWithdraw = await canWithdrawVotes(daoRootContract.address, address)
    const canUnlock = await getUnlockArray(daoRootContract, address)
    console.log('canUnlock: ', canUnlock)
    await getVotes(daoRootContract.address, address)

    // console.log('prop: ', prop)
    rootData = {
      name: name.name,
      slug: slug.slug,
      description: description.description,
      token: tokenSymbol ? tokenSymbol.label : null,
      proposalConfiguration: proposalConfiguration.proposalConfiguration,
      nrOfProposals: nrOfProposals.proposalCount,
      daoBalance: balance,
      userBalance: userBalance,
      daoAddress: daoRootContract.address,
      proposals: proposals,
      proposalsWithLockedTokens: prop ?? null,
      voters: voters,
      tokenBalance: tokenBalance,
      history: history,
      withdraw: canWithdraw,
      unlockArray: canUnlock,
      decimals: tokenSymbol ? tokenSymbol.decimals : null,
      tokenRootAddress: tokenRootAddress,
      tokenName: tokenSymbol ? tokenSymbol.name : null,
    }
  }

  return new Promise((resolve) => {
    resolve(rootData)
  })
}

async function setSettingsChanges(name, slug, description, daoAddress) {
  let daoRootAddress = daoAddress

  try {
    const providerState = await ever.getProviderState()
    const publicKey = providerState.permissions.accountInteraction.publicKey
    const daoRoot = new ever.Contract(daoRootAbi, daoRootAddress)
    const trx = await daoRoot.methods
      .updateDetails({ name_: name, slug_: slug, description_: description })
      .sendExternal({
        publicKey: publicKey,
        withoutSignature: true,
      })

    return Promise.resolve(trx)
  } catch (e) {
    // console.log('error: ', e)
    return Promise.reject(e)
  }
}

const getDaoByAddress = async (address) => {
  const daoRootContract = new ever.Contract(daoRootAbi, address)
  try {
    return Promise.resolve(daoRootContract)
  } catch (e) {
    // console.log(e)
    return Promise.reject(e)
  }
}

let dateNow = new Date().getTime()
const getProposals = async (daoRootAddress) => {
  const daoRoot = new ever.Contract(daoRootAbi, daoRootAddress)
  //const slug = await daoRoot.methods.slug({}).call()
  const counter = await daoRoot.methods.getProposalCount({ answerId: 0 }).call()
  let proposalDataArray = []
  for (let i = 0; i < counter.value0; i++) {
    const proposal = await createProposalContract(daoRootAddress, i + 1)
    proposalDataArray.push(proposal)
  }

  let proposals = []
  for (let i = 0; i < proposalDataArray.length; i++) {
    const data = await proposalDataArray[i].methods
      .getOverview({ answerId: 0 })
      .call()
    const proposalActions = await proposalDataArray[i].methods
      .getActions({ answerId: 0 })
      .call()
    let state
    if (data.state_ == 0) {
      state = 'Pending'
    } else if (data.state_ == 1) state = 'Active'
    else if (data.state_ == 2) state = 'Canceled'
    else if (data.state_ == 3) state = 'Failed'
    else if (data.state_ == 4) state = 'Succeeded'
    else if (data.state_ == 5) state = 'Expired'
    else if (data.state_ == 6) state = 'Queued'
    else if (data.state_ == 7) state = 'Executed'
    else state = 'Unknown'
    const time = Math.ceil(
      (new Date(
        dayjs.unix(data.endTime_).format('DD MMM YYYY HH:mm')
      ).getTime() -
        dateNow) /
        (1000 * 3600 * 24)
    )
    const options = { weekday: 'short' }
    const timeToDate = new Date(data.startTime_ * 1000).toLocaleString(
      'en-US',
      options
    )
    console.log('time to Date: ', timeToDate)
    const date = dayjs.unix(data.startTime_).format('D.M')
    console.log('date short: ', date)
    const startEndDifference = Math.ceil(
      new Date(
        dayjs.unix(data.startTime_).format('DD MMM YYYY HH:mm')
      ).getTime() -
        new Date(
          dayjs.unix(data.endTime_).format('DD MMM YYYY HH:mm')
        ).getTime()
    )
    console.log('start end difference: ', startEndDifference)
    const monthNames = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December',
    ]
    const month =
      monthNames[
        new Date(
          dayjs.unix(data.startTime_).format('DD MMM YYYY HH:mm')
        ).getMonth()
      ]
    const daysDifference = parseMillisecondsIntoReadableTime(
      startEndDifference * -1
    )
    console.log('days difference: ', daysDifference)
    let numberOfDifference
    if (
      daysDifference.split(' ')[1] == 'minutes' ||
      daysDifference.split(' ')[1] == 'hours'
    ) {
      numberOfDifference = 0
      console.log('numberDifference: ', numberOfDifference)
    } else {
      numberOfDifference = daysDifference.split(' ')[0]
      console.log('numberDifference: ', numberOfDifference)
    }
    const summ = data.description_.split('%')
    console.log('summary: ', summ)
    let description
    if (summ.length > 1) {
      description = summ[1]
    }
    const voters = await getVoters(daoRootAddress, i + 1)
    const timelineData = await timelineCalculation(daoRootAddress, i + 1)
    proposals.push({
      id: i + 1,
      summary: summ[0],
      status: state,
      voting: 'voting1',
      date: 'date1',
      forVotes: fromNano(data.forVotes_ * 1, 9),
      againstVotes: data.againstVotes_ * 1,
      endTime: dayjs.unix(data.endTime_).format('DD MMM YYYY HH:mm'),
      startTime: dayjs.unix(data.startTime_).format('DD MMM YYYY HH:mm'),
      actionInMS:
        new Date(
          dayjs.unix(data.endTime_).format('DD MMM YYYY HH:mm')
        ).getTime() - dateNow,
      actionInDays: Math.ceil(
        (new Date(
          dayjs.unix(data.endTime_).format('DD MMM YYYY HH:mm')
        ).getTime() -
          dateNow) /
          (1000 * 3600 * 24)
      ),
      queuedTime: dayjs.unix(data.executionTime_).format('DD MMM YYYY HH:mm'),
      //slug: slug.slug,
      proposalActions: proposalActions.value0,
      dayForTimeline: timeToDate,
      dayDifference: numberOfDifference * 1,
      month: month,
      dateShort: date,
      description: description ? description : '',
      voters: voters,
      timeline: timelineData,
    })
  }

  return proposals
}

const getAllStakeholders = async (daoRootAddress) => {
  const stakingRoot = await createStakingContract(daoRootAddress)

  const successStream = await ever.getTransactions({
    address: stakingRoot.address,
    continuation: undefined,
    limit: 20,
  })
  let voters = []
  for (let i = 0; i < successStream.transactions.length; i++) {
    const trx = await stakingRoot.decodeTransaction({
      transaction: successStream.transactions[i],
      methods: ['castVote'],
    })
    let duplicate
    if (trx) {
      if (voters) {
        duplicate = voters.find(
          (voter) =>
            voter === successStream.transactions[i].inMessage.src._address
        )
      }
      if (!duplicate) {
        voters.push(successStream.transactions[i].inMessage.src._address)
      }
    }
  }
  let votesData = []
  for (let i = 0; i < voters.length; i++) {
    const userData = await createUserDataContract(daoRootAddress, voters[0])
    const votes = await userData.methods.lockedTokens({ answerId: 0 }).call()
    const castedVotes = await userData.methods.casted_votes({}).call()

    votesData.push({
      id: i + 1,
      userAddress: voters[i],
      voteWeight: 100,
      votes: votes.value0,
      proposalsVoted: castedVotes.casted_votes.length,
    })
  }

  return votesData
}

const createProposal = async (
  ownerAddress,
  daoRoot,
  description,
  deployedActions
) => {
  try {
    let tonActionsList = []
    for (let i = 0; i < deployedActions.length; i++) {
      tonActionsList.push({
        value: toNano(deployedActions[i].value, 9),
        target: deployedActions[i].target,
        payload: deployedActions[i].payload,
      })
    }
    const rootDao = createDaoRootContract(daoRoot)
    const token = await rootDao.methods.governanceToken({}).call()
    const rootAcc = new ever.Contract(rootAbi, token.governanceToken)
    const response = await rootAcc.methods
      .walletOf({
        answerId: 1,
        walletOwner: ownerAddress,
      })
      .call()
    const stakingRootAddress = await rootDao.methods
      .getStakingRoot({ answerId: 0 })
      .call()
    const tokenAmount = await rootDao.methods.minStake({}).call()
    const userTokenWalletAddress = response.value0._address
    const tokenWalletAddress = new Address(userTokenWalletAddress)
    const walletContract = new ever.Contract(giver, tokenWalletAddress)
    const sendTransaction = await walletContract.methods
      .transfer({
        amount: tokenAmount.minStake,
        recipient: stakingRootAddress.value0,
        deployWalletValue: 0, //toNano(0.5, 9),
        remainingGasTo: ownerAddress,
        notify: true,
        payload: 'te6ccgEBAQEAAwAAAgA=',
      })
      .send({
        from: ownerAddress,
        amount: toNano(10.5, 9),
        bounce: true,
      })

    let ethActions = []
    const propose = await rootDao.methods
      .propose({
        answerId: 0,
        tonActions: tonActionsList,
        ethActions: ethActions,
        description: description,
      })
      .send({
        from: ownerAddress,
        amount: toNano(10 + tonActionsList.length * 2, 9),
        bounce: false,
      })
    const deployEvent = await rootDao.getPastEvents({
      range: { fromLt: propose.id.lt * 1 - 1 },
    })
    return Promise.resolve(deployEvent)
  } catch (e) {
    return Promise.reject(e)
  }
}

const proposalsWithYourLockedTokens = async (ownerAddress, daoRootAddress) => {
  try {
    // const daoRoot = createDaoRootContract(daoRootAddress)
    // const slug = await daoRoot.methods.slug({}).call()
    const userData = await createUserDataContract(daoRootAddress, ownerAddress)
    const lockedTokens = await userData.methods
      .lockedTokens({ answerId: 0 })
      .call()
    const contractState = await ever.getFullContractState({
      address: userData.address,
    })
    let proposalContractArray = []
    if (contractState.state.isDeployed) {
      const count = await userData.methods.created_proposals({}).call()
      for (let i = 0; i < count.created_proposals.length; i++) {
        const proposal = await createProposalContract(daoRootAddress, i + 1)
        proposalContractArray.push(proposal)
      }
    }

    let proposals = []
    for (let i = 0; i < proposalContractArray.length; i++) {
      const data = await proposalContractArray[i].methods
        .getOverview({ answerId: 0 })
        .call()
      let state
      if (data.state_ == 0) {
        state = 'Pending'
      } else if (data.state_ == 1) state = 'Active'
      else if (data.state_ == 2) state = 'Canceled'
      else if (data.state_ == 3) state = 'Failed'
      else if (data.state_ == 4) state = 'Succeeded'
      else if (data.state_ == 5) state = 'Expired'
      else if (data.state_ == 6) state = 'Queued'
      else if (data.state_ == 7) state = 'Executed'
      else state = 'Unknown'

      const summ = data.description_.split('%')

      proposals.push({
        id: i + 1,
        summary: summ[0],
        status: state,
        voting: 'voting1',
        date: 'date1',
        forVotes: fromNano(data.forVotes_ * 1, 9),
        againstVotes: data.againstVotes_ * 1,
        endTime: dayjs.unix(data.endTime_).format('DD MMM YYYY HH:mm'),
        startTime: dayjs.unix(data.startTime_).format('DD MMM YYYY HH:mm'),
        actionInMS:
          new Date(
            dayjs.unix(data.endTime_).format('DD MMM YYYY HH:mm')
          ).getTime() - dateNow,
        actionInDays: Math.ceil(
          (new Date(
            dayjs.unix(data.endTime_).format('DD MMM YYYY HH:mm')
          ).getTime() -
            dateNow) /
            (1000 * 3600 * 24)
        ),
        queuedTime: dayjs.unix(data.executionTime_).format('DD MMM YYYY HH:mm'),
        lockedTokens: lockedTokens.value0,
        //   slug: slug.slug,
      })
    }

    return Promise.resolve(proposals)
  } catch (e) {
    return null
  }
}

const stakeTokens = async (daoRootAddress, ownerAddress, amount) => {
  try {
    const rootDao = createDaoRootContract(daoRootAddress)
    const token = await rootDao.methods.governanceToken({}).call()
    const rootAcc = new ever.Contract(rootAbi, token.governanceToken)
    const response = await rootAcc.methods
      .walletOf({
        answerId: 1,
        walletOwner: ownerAddress,
      })
      .call()
    const stakingRootAddress = await rootDao.methods
      .getStakingRoot({ answerId: 0 })
      .call()
    const decimals = await rootAcc.methods.decimals({ answerId: 0 }).call()
    const tokenAmount = await rootDao.methods.minStake({}).call()
    const userTokenWalletAddress = response.value0._address

    const tokenWalletAddress = new Address(userTokenWalletAddress)
    const walletContract = new ever.Contract(giver, tokenWalletAddress)
    const tokenWallet = new ever.Contract(tokenWalletAbi, tokenWalletAddress)
    const tokenBalance = await tokenWallet.methods
      .balance({ answerId: 0 })
      .call()

    const sendTransaction = await walletContract.methods
      .transfer({
        amount: toNano(amount, decimals.value0 * 1),
        recipient: stakingRootAddress.value0,
        deployWalletValue: 0, //toNano(0.5, 9),
        remainingGasTo: ownerAddress,
        notify: true,
        payload: 'te6ccgEBAQEAAwAAAgA=',
      })
      .send({
        from: ownerAddress,
        amount: toNano(10.5, 9),
        bounce: true,
      })

    return Promise.resolve(sendTransaction)
  } catch (e) {
    return Promise.reject(e)
  }
}

const withdrawTokens = async (daoRootAddress, ownerAddress, amount) => {
  const stakingContract = await createStakingContract(daoRootAddress)
  try {
    const withdraw = await stakingContract.methods
      .withdraw({
        ////MORA SE ISPRAVITI DECIMALA
        amount: toNano(amount, 9),
        send_gas_to: ownerAddress,
      })
      .send({
        from: ownerAddress,
        amount: toNano(10.5, 9),
        bounce: false,
      })
    return Promise.resolve(withdraw)
  } catch (e) {
    return Promise.reject(e)
  }
}

const calculateBalance = async (ownerAddress, tokenAddr) => {
  try {
    const rootAcc = new ever.Contract(rootAbi, tokenAddr)
    const response = await rootAcc.methods
      .walletOf({
        answerId: 1,
        walletOwner: ownerAddress,
      })
      .call()

    const decimals = await rootAcc.methods.decimals({ answerId: 0 }).call()
    const userTokenWalletAddress = response.value0._address

    const tokenWalletAddress = new Address(userTokenWalletAddress)
    const tokenWallet = new ever.Contract(tokenWalletAbi, tokenWalletAddress)
    const tokenBalance = await tokenWallet.methods
      .balance({ answerId: 0 })
      .call()
    return fromNano(tokenBalance.value0 * 1, decimals.value0 * 1)
  } catch {
    return null
  }
}

function parseMillisecondsIntoReadableTime(milliseconds) {
  var days = milliseconds / (1000 * 60 * 60 * 24)
  var absoluteDays = Math.floor(days)
  if (absoluteDays > 0) {
    return `${absoluteDays} days ago`
  }
  //Get hours from milliseconds
  var hours = milliseconds / (1000 * 60 * 60)
  var absoluteHours = Math.floor(hours)
  var h = absoluteHours > 9 ? absoluteHours : '0' + absoluteHours
  if (absoluteDays < 1 && absoluteHours > 0) {
    return `${absoluteHours} hours ago`
  }
  //Get remainder from hours and convert to minutes
  var minutes = (hours - absoluteHours) * 60
  var absoluteMinutes = Math.floor(minutes)
  var m = absoluteMinutes > 9 ? absoluteMinutes : '0' + absoluteMinutes
  if (absoluteDays < 1 && absoluteHours < 1 && absoluteMinutes > 0) {
    return `${absoluteMinutes} minutes ago`
  }

  //Get remainder from minutes and convert to seconds
  if (absoluteDays < 1 && absoluteHours < 1 && absoluteMinutes < 1) {
    var seconds = (minutes - absoluteMinutes) * 60
    var absoluteSeconds = Math.floor(seconds)
    var s = absoluteSeconds > 9 ? absoluteSeconds : '0' + absoluteSeconds
    return `${absoluteSeconds} seconds ago`
  }
}

const getTransactionHistory = async (daoRootAddress) => {
  try {
    const daoRoot = createDaoRootContract(daoRootAddress)
    const stakingRoot = await createStakingContract(daoRootAddress)
    const token = await daoRoot.methods.governanceToken({}).call()
    const tokenContract = new ever.Contract(rootAbi, token.governanceToken)
    const tokenName = await tokenContract.methods.symbol({ answerId: 0 }).call()
    const successStream = await ever.getTransactions({
      address: stakingRoot.address,
      continuation: undefined,
      limit: 50,
    })
    let voters = []
    for (let i = 0; i < successStream.transactions.length; i++) {
      const trx = await stakingRoot.decodeTransaction({
        transaction: successStream.transactions[i],
        methods: ['onAcceptTokensTransfer'],
      })
      const trx2 = await stakingRoot.decodeTransaction({
        transaction: successStream.transactions[i],
        methods: ['withdraw'],
      })
      if (trx) {
        const method = `Deposit ${tokenName.value0} tokens`
        const dt = new Date(successStream.transactions[i].createdAt * 1000)
        const date = new Date().getTime()
        const result = date - dt
        const parsed = parseMillisecondsIntoReadableTime(result)

        voters.push({
          transaction: method,
          amount: fromNano(trx.input.amount, 9),
          dateStaking: result,
        })
      }
      if (trx2) {
        const method = `Withdraw ${tokenName.value0} tokens`
        const dt = new Date(successStream.transactions[i].createdAt * 1000)
        const date = new Date().getTime()
        const result = date - dt
        voters.push({
          transaction: method,
          amount: fromNano(trx2.input.amount * -1, 9),
          dateStaking: result,
        })
      }
    }
    return Promise.resolve(voters)
  } catch (e) {
    return Promise.reject(e)
  }
}

const canWithdrawVotes = async (daoRootAddress, ownerAddress) => {
  let answer
  try {
    const userData = await createUserDataContract(daoRootAddress, ownerAddress)
    const contractState = await ever.getFullContractState({
      address: userData.address,
    })
    if (contractState?.state.isDeployed) {
      const created_proposals = await userData.methods
        .created_proposals({})
        .call()
      const tmp_proposals = await userData.methods._tmp_proposals({}).call()
      const votes = await userData.methods.casted_votes({}).call()

      if (
        created_proposals.created_proposals.length > 0 ||
        tmp_proposals._tmp_proposals.length > 0 ||
        votes.casted_votes.length > 0
      ) {
        answer = false
      } else {
        answer = true
      }
    } else answer = false

    return Promise.resolve(answer)
  } catch (e) {
    return false
  }
}

const getUnlockArray = async (daoRoot, ownerAddress) => {
  try {
    const userData = await createUserDataContract(daoRoot.address, ownerAddress)
    const castedVotes = await userData.methods.casted_votes({}).call()
    console.log('casted votes: ', castedVotes)
    let unlockArray = []
    if (castedVotes.casted_votes.length > 0) {
      for (let i = 0; i < castedVotes.casted_votes.length; i++) {
        const proposal = await createProposalContract(
          daoRoot.address,
          castedVotes.casted_votes[i][0] * 1
        )
        const state = await proposal.methods.getState({ answerId: 0 }).call()
        if (state.value0 == 0 || state.value0 == 1) {
          unlockArray.push(false)
        } else {
          unlockArray.push(true)
        }
      }
    }

    return Promise.resolve(unlockArray)
  } catch (e) {
    return Promise.reject(e)
  }
}

const canUnlockVotes = async (daoRoot, proposalId, ownerAddress) => {
  try {
    console.log('usao u unlock')
    let success = false
    if (proposalId != 0) {
      const userData = await createUserDataContract(daoRoot, ownerAddress)
      const castedVotes = await userData.methods.casted_votes({}).call()
      const isCasted = castedVotes.casted_votes.find(
        (vote) => vote[0] * 1 == proposalId
      )

      if (isCasted) {
        const proposal = await createProposalContract(daoRoot, proposalId)
        const state = await proposal.methods.getState({ answerId: 0 }).call()
        console.log('state.value: ', state.value0)
        if (state.value0 != 0 && state.value0 != 1) {
          success = true
        }
      }
    } else {
      const userData = await createUserDataContract(daoRoot, ownerAddress)
      const castedVotes = await userData.methods.casted_votes({}).call()

      let flag = 0
      if (castedVotes.casted_votes.length > 0) {
        for (let i = 0; i < castedVotes.casted_votes.length; i++) {
          const proposal = await createProposalContract(
            daoRoot,
            castedVotes.casted_votes[i][0] * 1
          )
          const state = await proposal.methods.getState({ answerId: 0 }).call()
          if (state.value0 == 0 || state.value0 == 1) {
            flag = 1
          }
        }
        if (flag == 0) success = true
      }
    }
    return Promise.resolve(success)
  } catch (e) {
    return false
  }
}

const unlockVotes = async (daoRootAddress, proposalId, ownerAddress) => {
  try {
    const stakingRoot = await createStakingContract(daoRootAddress)
    const success = await canUnlockVotes(
      daoRootAddress,
      proposalId,
      ownerAddress
    )
    let proposalIds = []
    let unlock
    if (success) {
      if (proposalId != 0) {
        proposalIds.push(proposalId)
        unlock = await stakingRoot.methods
          .tryUnlockCastedVotes({ proposal_ids: proposalIds })
          .send({
            from: ownerAddress,
            amount: toNano(15, 9),
            bounce: false,
          })
      } else {
        const userData = await createUserDataContract(
          daoRootAddress,
          ownerAddress
        )
        const castedVotes = await userData.methods.casted_votes({}).call()
        for (let i = 0; i < castedVotes.casted_votes.length; i++) {
          proposalIds.push(castedVotes.casted_votes[i][0] * 1)
        }
        unlock = await stakingRoot.methods
          .tryUnlockCastedVotes({ proposal_ids: proposalIds })
          .send({
            from: ownerAddress,
            amount: toNano(15, 9),
            bounce: false,
          })
      }
    }
    return Promise.resolve(unlock)
  } catch (e) {
    return Promise.reject(e)
  }
}

const createDaoRootContract = (daoRootAddress) => {
  const daoRoot = new ever.Contract(daoRootAbi, daoRootAddress)
  return daoRoot
}

const createStakingContract = async (daoRootAddress) => {
  const daoRoot = createDaoRootContract(daoRootAddress)
  try {
    const stakingAddress = await daoRoot.methods
      .getStakingRoot({ answerId: 0 })
      .call()
    const stakingRoot = new ever.Contract(stakingAbi, stakingAddress.value0)
    return Promise.resolve(stakingRoot)
  } catch (e) {
    return Promise.reject(e)
  }
}

const createUserDataContract = async (daoRootAddress, ownerAddress) => {
  const daoRoot = createDaoRootContract(daoRootAddress)
  try {
    const userDataAddress = await daoRoot.methods
      .getUserDataAddress({ answerId: 0, user: ownerAddress })
      .call()
    const userData = new ever.Contract(userDataAbi, userDataAddress.value0)

    return Promise.resolve(userData)
  } catch (e) {
    return Promise.reject(e)
  }
}

const createProposalContract = async (daoRootAddress, proposalId) => {
  const daoRoot = createDaoRootContract(daoRootAddress)
  try {
    const proposalAddr = await daoRoot.methods
      .expectedProposalAddress({
        answerId: 0,
        proposalId: proposalId,
      })
      .call()

    const proposal = new ever.Contract(proposalAbi, proposalAddr.value0)
    return Promise.resolve(proposal)
  } catch (e) {
    return Promise.reject(e)
  }
}

const getVotes = async (daoRootAddress, ownerAddress) => {
  const userData = await createUserDataContract(daoRootAddress, ownerAddress)
  const successStream = await ever.getTransactions({
    address: userData.address,
    continuation: undefined,
    limit: 50,
  })
  let votesData = []

  for (let i = 0; i < successStream.transactions.length; i++) {
    const trx = await userData.decodeTransaction({
      transaction: successStream.transactions[i],
      methods: ['castVote'],
    })

    if (trx) {
      console.log('trx: ', trx)
      const event = await userData.decodeTransactionEvents({
        transaction: successStream.transactions[i],
      })
      console.log('event: ', event)
      votesData.push({
        id: event[0].data.proposal_id,
        support: event[0].data.support,
        votes: fromNano(event[0].data.votes * 1, 9),
      })
    }
  }
  console.log('votes data: ', votesData)
  return Promise.resolve(votesData)
}

const isOwner = async (daoRootAddress, ownerAddress, proposalId) => {
  let owner = false
  const userData = await createUserDataContract(daoRootAddress, ownerAddress)
  const count = await userData.methods.created_proposals({}).call()
  for (let i = 0; i < count.created_proposals.length; i++) {
    const proposal = await createProposalContract(
      daoRootAddress,
      count.created_proposals[i][0] * 1
    )
    if (proposalId == count.created_proposals[i][0] * 1) {
      owner = true
    }
  }
  return Promise.resolve(owner)
}

const castVote = async (daoRootAddress, voteFor, proposalId, ownerAddress) => {
  try {
    const stakingRoot = await createStakingContract(daoRootAddress)
    const cast = await stakingRoot.methods
      .castVote({ proposal_id: proposalId, support: voteFor })
      .send({
        from: ownerAddress,
        amount: toNano(15, 9),
        bounce: false,
      })

    return Promise.resolve(cast)
  } catch (e) {
    return Promise.reject(e)
  }
}

const cancelProposal = async (proposalId, daoRootAddress, ownerAddress) => {
  try {
    const proposal = await createProposalContract(daoRootAddress, proposalId)
    const cancel = await proposal.methods.cancel({}).send({
      from: ownerAddress,
      amount: toNano(15, 9),
      bounce: false,
    })

    return Promise.resolve(cancel)
  } catch (e) {
    Promise.reject(e)
  }
}

const getVoters = async (daoRootAddress, proposalId) => {
  const proposal = await createProposalContract(daoRootAddress, proposalId)
  const successStream = await ever.getTransactions({
    address: proposal.address,
    continuation: undefined,
    limit: 50,
  })
  let votesData = []
  for (let i = 0; i < successStream.transactions.length; i++) {
    const trx = await proposal.decodeTransaction({
      transaction: successStream.transactions[i],
      methods: ['castVote'],
    })
    if (trx) {
      console.log('trx: ', trx)
      votesData.push({
        voter: trx.input.voter._address,
        vote: fromNano(trx.input.votes, 9),
      })
    }
  }
  return Promise.resolve(votesData)
}

const timelineCalculation = async (daoRootAddress, proposalId) => {
  const daoRoot = createDaoRootContract(daoRootAddress)
  const proposalConfiguration = await daoRoot.methods
    .proposalConfiguration({})
    .call()
  const days =
    (proposalConfiguration.proposalConfiguration.votingDelay * 1 +
      proposalConfiguration.proposalConfiguration.votingPeriod * 1 +
      proposalConfiguration.proposalConfiguration.timeLock * 1 +
      proposalConfiguration.proposalConfiguration.gracePeriod * 1) /
    (60 * 60 * 24)
  console.log('days: ', days)
  const proposal = await createProposalContract(daoRootAddress, proposalId)
  const data = await proposal.methods.getOverview({ answerId: 0 }).call()
  const options = { weekday: 'short' }
  let timelineArray = []
  for (let i = 0; i < days; i++) {
    const timeToDate = new Date(
      data.startTime_ * 1000 + 24 * 60 * 60 * i * 1000
    ).toLocaleString('en-US', options)
    console.log('time to Date: ', timeToDate)
    const adition = data.startTime_ * 1 + 24 * 60 * 60 * i
    console.log('adition: ', adition)
    const date = dayjs.unix(adition).format('D.M')
    console.log('date short: ', date)
    const dateNow = dayjs.unix(data.startTime_).format('D.M')
    console.log('dateNow: ', dateNow)
    console.log('data.start: ', data.startTime_)
    const monthNames = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December',
    ]
    const month =
      monthNames[
        new Date(dayjs.unix(adition).format('DD MMM YYYY HH:mm')).getMonth()
      ]
    timelineArray.push({
      date: date,
      weekday: timeToDate,
      month: month,
    })
  }
  console.log('timelineArray: ', timelineArray)
  return Promise.resolve(timelineArray)
}

const daoService = {
  getExpectedAddress,
  topup,
  deployFactory,
  deployDAOFromFactory,
  getFactory,
  getAllDAOs,
  getAddressForRoot,
  transferOwnership,
  destroy,
  getToken,
  getDaoInfo,
  findDaoBySlug,
  setSettingsChanges,
  getDaoByAddress,
  getProposals,
  getAllStakeholders,
  createProposal,
  stakeTokens,
  calculateBalance,
  withdrawTokens,
  getTransactionHistory,
  parseMillisecondsIntoReadableTime,
  unlockVotes,
  canUnlockVotes,
  castVote,
  cancelProposal,
}

export default daoService
